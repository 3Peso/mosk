"""mosk artefact base class module"""__version__ = '0.0.7'__author__ = '3Peso'__all__ = ['ArtefactBase']import loggingfrom datetime import datetimefrom abc import abstractmethodfrom collections import UserDictfrom baseclasses.source import SourceBasefrom baseclasses.protocol import ProtocolBasefrom businesslogic.placeholders import Placeholderfrom businesslogic.data import CollectionDatafrom businesslogic.support import get_collector_resourcesclass ArtefactBase(object):    """    Base class for all artefact collection classes.    """    _logger = logging.getLogger(__name__)    def __init__(self, parent: SourceBase, parameters, *args, **kwargs):        self._parent = SourceBase(parent, parameters)        self._parameters = parameters        self._collecteddata = []        self._protocol = None        self._init_description_properties()        #self._title = None        #self._collectionmethod = None        #self._description = None        ArtefactBase.cache_parameters(self._parameters)        self._set_parameters_as_attributes(parameters)    def getdocumentation(self) -> str:        try:            # Example            # Title: CurrentUser            # Description: Collects the current user name on the local host.            # Collection Method: getpass.getuser()            documentation = "Title: {}\nDescription: {}\nCollection Method: {}".format(self._title,                                                                                       self._description,                                                                                       self._collectionmethod)        except TypeError:            documentation = ""        return documentation    def __call__(self):        return self.collect()    def __str__(self):        if self.data is None:            ArtefactBase._logger.warning("ArtefactBase: Collected data of '{}' is None".format(self._title))        else:            ArtefactBase._logger.debug(                "ArtefactBase: Collected data of '{}' converted to string in ArtefactBase.__str__".                format(self._title))            data_as_string = ''            if hasattr(self.data, '__iter__'):                for dataobj in self.data:                    # HACK                    # Adding this collector metadata here is not the best place. Normally this should be                    # done during collection time. But I havn't figured out a place where to put this                    # without the need to change every collector there is. So, as long as the collector                    # metadata is only used in __str__ it can stay here.                    dataobj._collector_name = self.get_subclass_name()                    dataobj._collector_parameters = self._parameters                    data_as_string += "{}\r\n".format(str(dataobj))            else:                data_as_string = str(self.data)        return data_as_string    def _set_parameters_as_attributes(self, parameters):        for parameter, value in parameters.items():            setattr(self, parameter, Placeholder.replace_placeholders(value))            parameters[parameter] = Placeholder.replace_placeholders(value)    def _init_description_properties(self):        self._title = None        self._description = None        self._collectionmethod = None        resources = get_collector_resources()        try:            resources = resources[self.get_subclass_name()]            self._title = resources['title']            self._description = resources['description']            self._collectionmethod = resources['collectionmethod']        except KeyError:            self._logger.info('No resource string for collector "{}" in resources.'.format(self.get_subclass_name()))    # From: https://stackoverflow.com/questions/19335722/getting-name-of-subclass-from-superclass    def get_subclass_name(self):        return "{}.{}".format(self.__class__.__module__, self.__class__.__name__)    @classmethod    def cache_parameters(cls, attributes: UserDict):        """Cache placeholder values for later usage in following commands."""        for attributename in attributes.keys():            attributevalue = Placeholder.replace_placeholders(attributes[attributename])            Placeholder.update_placeholder(attributename, attributevalue)            ArtefactBase._logger.debug("Artefact: Cached artefact parameter '{}'. Parameter value: '{}'".                                       format(attributename, attributevalue))    @abstractmethod    def collect(self) -> dict:        pass    @property    def protocol(self):        return self._protocol    @protocol.setter    def protocol(self, newprotocol: ProtocolBase):        self._protocol = newprotocol    @property    def data(self):        """        :return:        List with collected data objects.        """        return self._collecteddata    @data.setter    def data(self, value):        """        Setter to append more collected data to a list with data objects.        :param value: If value is 'None' the list is emptied.        :return:        """        if value is None:            self._collecteddata = []        else:            self._collecteddata.append(CollectionData(data=value, currentdatetime=datetime.now()))    @Placeholder    def get_parameter(self, parameter):        parametervalue = self._parameters[parameter]        self._logger.debug("Retrieved parameter '{}': '{}'".format(parameter, parametervalue))        return parametervalue